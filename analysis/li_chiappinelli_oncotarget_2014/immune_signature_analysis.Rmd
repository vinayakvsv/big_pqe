---
title: "Li and Chiappinelli Immune signature analysis"
output: html_notebook
---

# Setup packages
```{r setup}
source("https://bioconductor.org/biocLite.R")
biocLite("Biobase")
biocLite("GEOquery")
biocLite("limma")
```



# Import the data

```{r sig1}
# Version info: R 3.2.3, Biobase 2.30.0, GEOquery 2.40.0, limma 3.26.8
# R scripts generated  Thu Aug 30 14:01:47 EDT 2018

################################################################
#   Differential expression analysis with limma
library(Biobase)
library(GEOquery)
# source("GEOpatch.R")
library(limma)
```

```{r downloadgeo}
# load series and platform data from GEO
li_et_al_2014_data <- paste(getwd(),"../..","datasets","li_chiappinelli_oncotarget_2014/",sep = "/")
gset0 <- getGEO("GSE57341",destdir = li_et_al_2014_data)
if (length(gset0) > 1) {
  idx <- grep("GPL4133", attr(gset, "names")) 
} else {
  idx <- 1
}

gset <- gset0[[idx]]

# make proper column names to match toptable 
fvarLabels(gset) <- make.names(fvarLabels(gset))

```

Test out limma...

```{r define_conditions}

# group names for all samples
gsms <- paste0("XXXX0000XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
        "XXXXXXXXXXX1111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
        "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
        "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
        "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
sml <- c()
for (i in 1:nchar(gsms)) { sml[i] <- substr(gsms,i,i) }

# eliminate samples marked as "X"
sel <- which(sml != "X")
sml <- sml[sel]
gset_reduced <- gset[ ,sel]

# log2 transform
ex <- exprs(gset_reduced)
qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
          (qx[6]-qx[1] > 50 && qx[2] > 0) ||
          (qx[2] > 0 && qx[2] < 1 && qx[4] > 1 && qx[4] < 2)
# invoke this if log2 normalization isn't already in effect
if (LogC) { ex[which(ex <= 0)] <- NaN
  exprs(gset_reduced) <- log2(ex) }
```

```{r limmafit}
# set up the data and proceed with analysis
sml <- paste("G", sml, sep="")    # set group names
fl <- as.factor(sml)
gset_reduced$description <- fl
design <- model.matrix(~ description + 0, gset_reduced) # perhaps we can 
colnames(design) <- levels(fl)
fit <- lmFit(gset_reduced, design)
cont.matrix <- makeContrasts(G1-G0, levels=design)
# fit1 <- contrasts.fit(fit,cont.matrix)
fit2 <- contrasts.fit(fit, cont.matrix)
# fit1 <- eBayes(fit1, 1)
fit2 <- eBayes(fit2, 0.01)
tT <- topTable(fit2, adjust="fdr", sort.by="B", number=250)
# allT <- topTable(fit2, adjust="none", sort.by="B",number = nrow(fit2))
tT <- topTable(fit2, adjust="fdr", sort.by="B",number = nrow(fit2))

# write results
write.table(x = tT,file = paste(getwd(),"topTable.txt",sep = "/"),quote = FALSE,sep = "\t",row.names = TRUE,col.names = TRUE)

# allT_subset <- subset(allT, select=c("ID","adj.P.Val","P.Value","t","B","logFC","GENE_SYMBOL","GENE_NAME"))
tT_subset <- subset(tT, select=c("ID","adj.P.Val","P.Value","t","B","logFC","GENE_SYMBOL","GENE_NAME"))
```

Volcano plot of the results
```{r volc_plot}
alpha <- 0.01
plot(tT_subset$logFC,
     -log10(tT_subset$adj.P.Val),
     xlab=c("logFC"),
     ylab="adj.P.val",
     pch=20,
     col=as.factor(tT_subset$adj.P.Val <= alpha))
```

```{}
################################################################
# #   Boxplot for selected GEO samples
# # library(Biobase)
# # library(GEOquery)
# 
# # load series and platform data from GEO
# 
# gset <- getGEO("GSE57341", GSEMatrix =TRUE, getGPL=FALSE)
# if (length(gset) > 1) idx <- grep("GPL4133", attr(gset, "names")) else idx <- 1
# gset <- gset[[idx]]
# 
# # group names for all samples in a series
# gsms <- paste0("XXXX0000XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
#         "XXXXXXXXXXX1111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
#         "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
#         "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
#         "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
# sml <- c()
# for (i in 1:nchar(gsms)) { sml[i] <- substr(gsms,i,i) }
# sml <- paste("G", sml, sep="")  # set group names
# 
# # eliminate samples marked as "X"
# sel <- which(sml != "X")
# sml <- sml[sel]
# gset <- gset[ ,sel]

# order samples by group
ex <- exprs(gset)[ , order(sml)]
sml <- sml[order(sml)]
fl <- as.factor(sml)
labels <- c("ZR-75-1","ZR-75-30")

# set parameters and draw the plot
palette(c("#dfeaf4","#f4dfdf", "#AABBCC"))
dev.new(width=4+dim(gset)[[2]]/5, height=6)
par(mar=c(2+round(max(nchar(sampleNames(gset)))/2),4,2,1))
title <- paste ("GSE57341", '/', annotation(gset), " selected samples", sep ='')
boxplot(ex, boxwex=0.6, notch=T, main=title, outline=FALSE, las=2, col=fl)
legend("topleft", labels, fill=palette(), bty="n")

```


## Goals of this analysis 

I would like to...

1. Compare the Aza-treated cell lines with non-treated cell lines across the . Specifically, find the genes that are not differentially expressed amongst the Aza-treated cell lines but are all differentially expressed with respect to their untreated counterparts. Keep the "up" and "down" genes separately
2. For each cell line studied, find the genes that go up 
3. Determine whether this signature is enriched for immune genes (use GSVA for this purpose)

# Compare the three cell lines

See Li et al Oncotarget 2014 Table 1 in “Interferon” for “Common to all 3 cancers” . The gene common to all three cancers in the interferon response where:

1. B2M (part of MHCI)
2. CD44
3. GBP1
4. HLA-B
5. HLA-C
6. ICAM-1
7. IRF7
8. IRF9
9. MT2A
10. OAS1
11. OAS2
12. OAS3
13. OASL
14. STAT1
16. EGR1
17. IFI27
18. IFI6
19. IFIT1
20. IFIT3
21. IFITM1
22. ISG15
23. ISG20
24. MX1
26. PSMB8
27. USP18
28. XAF1
29. DDX58
30. HRC5
31. UBA7
32. IFIH1
33. TNFA1P3

To define the Chiappinelli signature (and answer question #2 for Chiappinelli), we need to isolate AIMs. From Li et al Oncotarget: "AIMs were defined by intersection of all genes from the enriched GSEA gene sets with over 2 fold upregulated genes after AZA treatment for any cell line, any time point." So, for the analysis, perform every time-point contrast for each cell line and identify the genes. 

## log2 transform
```{r}
# log2 transform
exfull <- exprs(gset)
# remove NAs
gset_trsf <- gset
qxfull <- as.numeric(quantile(exfull, c(0., 0.25, 0.5, 0.75, 0.99,1.0), na.rm=T))
LogCfill <- (qxfull[5] > 100) ||
          (qxfull[6]-qxfull[1] > 50 && qxfull[2] > 0) ||
          (qxfull[2] > 0 && qxfull[2] < 1 && qxfull[4] > 1 && qxfull[4] < 2)
# invoke this if log2 normalization isn't already in effect
if (LogCfill) { 
  exfull[which(exfull <= 0)] <- NaN
  exprs(gset_trsf) <- log2(exfull) 
  } else if (qxfull[6] > 100) {
  # if the qxfull[6] full is extremely high...
    print("adjusting values")
    # remove extremely high values; since these are log2 fold changes, we don't want anything insanely high
    exfull[which(exfull >= 10)] <- NA
    # also remove extremely low values
    exfull[which(exfull < -10)] <- NA
    exprs(gset_trsf) <- exfull
}

# remove all rows that are all NA's
gset_trsf_with_NA <- apply(X = gset_trsf,
                           MARGIN = 1,
                           function(x) {
                             #length(x[is.na(x)]) > 10
                             length(x[is.na(x)]) == length(x)
                             })
gset_trsf_with_NA <- gset_trsf_with_NA[gset_trsf_with_NA]
# these genes have NA's
# exprs(gset_trsf) <- exfull[!rownames(exfull) %in% names(gset_trsf_with_NA),]


```

## set up design matrix

Get the metadata for the study
```{r set_design}
gset_meta <- data.frame(cell_line = gset_trsf$`cell line:ch1`,
                        cell_type = gset_trsf$`cell type:ch2`,
                        time = gset_trsf$`time point:ch1`,
                        source_ch1 = gset_trsf$source_name_ch1,
                        source_ch2 = gset_trsf$source_name_ch2)
rownames(gset_meta) <- gset_trsf$geo_accession
```

Note that every sample consists of two channels: one corresponding to the control (untreated) and one corresponding to the AZA. So, every sample will have a set of genes that differ in the treatment versus a control. For each gene, the colors for one of the two channel indicates whether the gene has a raised expression level in the treatment or control. We want to examine whether the genes that differ for one set of channels corresponding to a condition are different as the genesthat differ for another set of channels corresponding to a different condition.

We will compare the following: 
1. Each of the timepoints -- we want those genes that increase in expression 2-fold for any time point
2. Each type of tissue

```{r set_by_time}
timepoint <- sapply(X = unique(gset_meta$time),
                    function(t) {
                      a <- which(grepl(pattern = paste0(t,"$"),x = gset_meta$time,perl = TRUE))
                      names(a) <- rep(t,length(a))
                      a
                      })
timepoint <- sort(unlist(timepoint))
#names(timepoint) <- unique(gset_meta$time)
```

```{r set_by_cell_type}

is_breast <- which(grepl(pattern = "breast",x = gset_meta$cell_type))
breast_group <- rep('breast',length(is_breast))

is_ovarian <- which(grepl(pattern = "ovarian",x = gset_meta$cell_type))
ovarian_group <- rep('ovarian',length(is_ovarian))

is_colon <- which(grepl(pattern = "colon",x = gset_meta$cell_type))
colon_group <- rep('colon',length(is_colon))

by_celltype_time <- data.frame(sample = c(is_breast,is_ovarian,is_colon), 
                               cellgroup = as.factor(c(breast_group,ovarian_group,colon_group)))

# by_celltype_time <- data.frame(cellgroup = as.factor(c(breast_group,ovarian_group,colon_group)))

by_celltype_time <- by_celltype_time[order(by_celltype_time$sample),]
by_celltype_time$time <- as.factor(names(timepoint))
# by_celltype_time <- subset(by_celltype_time,select=c("cellgroup","time"))

# convert these into three groups and, when doing the comparison, see 13.3 in http://www.bioconductor.org/packages/devel/bioc/vignettes/limma/inst/doc/usersguide.pdf 


```

Set the group design. For this analysis, we will do the following:
1. Isolate the samples corresponding to each tissue type
2. For each tissue type, find the genes that go up significantly at any time point by at least 2-fold (log2FC = 1)
3. Identify the genes that are common to all of the tissue types. 
We will then perform GSEA on this set of "common genes" and recover our putative AIM signature

```{r set_designs_and_fit}
by_cell_fits <- lapply(unique(by_celltype_time$cellgroup),
                      function(x) {
                        x.meta <- subset(by_celltype_time,cellgroup %in% x)
                        # x.gset <- gset_trsf[,x.meta$sample]
                        x.gset <- gset_trsf[,x.meta$sample]
                        x.design <- model.matrix(~ 0 + time, 
                                     x.meta)
                        # remove the zero-columns
                        x.design <- x.design[,colSums(x.design) > 0]
                        x.fit <- lmFit(x.gset, x.design)
                        x.fit
                      })
names(by_cell_fits) <- unique(by_celltype_time$cellgroup)
```

```{}
gset$bycell <- as.factor(by_celltype_time$cellgroup)
gset$bytime <- as.factor(by_celltype_time$time)
# contrasts.args
contrasts_args <- lapply(by_celltype_time, contrasts, contrasts = FALSE)
# use the contrasts that we defined in contrasts_args to set the design matrix
# zero-out the coefficients
design_bycell_bytime <- model.matrix(~ 0 + time, 
                                     by_celltype_time,
                                     contrasts.arg = contrasts_args) 
# colnames(design) <- c(unique(by_cell_type$cellgroup),unique(gset$bytime))
```

## fit model 
Fit model
```{}
by_cell_fits <- lmFit(gset, design_bycell_bytime)
```

## extract tests and genes
Extract p-values, t-statistics, and B-statistics
```{r ebayes_decidetests_topT}
alpha <- 0.05
avgExp_min <- -100
avgExp_max <- 1000
# moderated t-statistic
# fit_bycell_bytime_ebayes <- eBayes(fit = fit_bycell_bytime,
#                                    proportion = alpha)
by_cell_fits_ebayes <- lapply(by_cell_fits,
                              function(x) {
                                eBayes(fit = x,
                                       proportion = alpha)
                              })
names(by_cell_fits_ebayes) <- names(by_cell_fits)

# decide tests
by_cell_fits_decideTests <- lapply(by_cell_fits_ebayes,
                              function(x) {
                                decideTests(object = x,
                                            method = "global",
                                            adjust.method = "fdr",
                                            p.value = alpha)
                              })
names(by_cell_fits_decideTests) <- names(by_cell_fits)

# decide tests
by_cell_fits_topTables <- lapply(by_cell_fits_ebayes,
                              function(x) {
                                topTable(fit = x,
                                         adjust = "fdr",
                                         sort.by = "B",
                                         number = nrow(x),
                                         p.value = alpha)
                              })
names(by_cell_fits_topTables) <- names(by_cell_fits)
```

```{r immunesig}
# isolate the genes that undergo significant changes at the time points described
# fortunately, the authors also included the GO terms of which each gene is a part. Isolate the interferon sets for each one

immune <- paste("immune",sep = "|")
controlsig <- paste("mitochondrion",sep = "|")
interferon <- paste("interferon",sep = "|")

sig_up_genes <- lapply(seq_along(along.with = by_cell_fits_decideTests),
                    function(x) {
                      x.decide <- by_cell_fits_decideTests[[x]]
                      x.tT <- by_cell_fits_topTables[[x]]
                      # remove the NAs
                      x.decide.sig <- apply(X = x.decide,MARGIN = 1,
                                            function(x) {
                                              # return TRUE if at least one 1 is in the row and if NA's do not dominate the row
                                              length(x[x == 1]) >= 1 & length(x[is.na(x)]) < length(x)
                                            })
                      x.decide_sig <- x.decide[x.decide.sig,]
                      # extract the entries that are significant at a particular time point
                      # also, extract based on the signature
                      x.tT <- x.tT[rownames(x.tT) %in% rownames(x.decide_sig),]
                      # x.tT <- subset(x.tT,AveExpr >= avgExp_min & AveExpr <= avgExp_max)
                      # x.tT_signature <- x.tT[grep(pattern = signature,x = x.tT$GO_ID,ignore.case = TRUE),]
                      x.tT
                      #x.decide[rownames(x.decide) %in% rownames(!is.na(x.decide)),]
                    })
names(sig_up_genes) <- names(by_cell_fits_decideTests)

# extract the interferon signature
sig_up_genes_in_signature <- lapply(seq_along(along.with = sig_up_genes),
                                 function(x) {
                                   x.tT <- sig_up_genes[[x]]
                                   x.tT_signature <- x.tT[grep(pattern = interferon,x = x.tT$GO_ID,ignore.case = TRUE),]
                                   x.tT_signature
                                 })
names(sig_up_genes_in_signature) <- names(by_cell_fits_decideTests)

```

## plot

```{r}
plot_sig_up_genes <- lapply(seq_along(along.with = sig_up_genes),
                         function(x) {
                           x.tT <- by_cell_fits_topTables[[x]]
                           x.tT.sig <- sig_up_genes[[x]]
                           # all points
                           # ylim_padj <- min(x.tT.sig$"adj.P.Val",na.rm = TRUE)
                           # print(-log10(ylim_padj))
                           plot(x.tT$AveExpr,
                                -log10(x.tT$adj.P.Val),
                                pch=20,
                                main=names(sig_up_genes)[x],
                                xlab=c("Average log2 expression"),
                                ylab=c("-log10(adj p value)"),
                                xlim=c(-3,3),
                                ylim=c(0,100))
                           abline(h = -log10(alpha),
                                  lty=2,
                                  col="red",
                                  lwd=2)
                           # sig genes
                           points(x.tT.sig$AveExpr,
                                -log10(x.tT.sig$adj.P.Val),
                                pch=20,
                                col="grey")
                           # sig genes in signature
                           x.tT.signature <- sig_up_genes_in_signature[[x]]
                           points(x.tT.signature$AveExpr,
                                -log10(x.tT.signature$adj.P.Val),
                                pch=20,
                                col="pink")
                         })
```

The putative "interferon signature" is 

```{r test_ifn_signature}
test_ifn_signature <- unique(unlist(lapply(sig_up_genes_in_signature,function(x) {unique(x$GENE_SYMBOL)})))
test_ifn_signature_probeInd <- unique(unlist(lapply(sig_up_genes_in_signature,function(x) {rownames(x)})))
test_ifn_signature_probeInd_genes <- lapply(sig_up_genes_in_signature,
                                            function(x) {
                                              x.df <- data.frame(gene = x$GENE_SYMBOL,
                                                                 rname = rownames(x))
                                              x.df
                                              })
test_ifn_signature_probeInd_genes <- do.call(rbind,test_ifn_signature_probeInd_genes)
test_ifn_signature_probeInd_genes <- aggregate.data.frame(x = test_ifn_signature_probeInd_genes,by = list(test_ifn_signature_probeInd_genes$rname),unique)

print(test_ifn_signature)
```

Heatmap
```{r}
library(pheatmap)
gset_log2exp <- exprs(gset_trsf)
gset_log2exp_pass <- gset_log2exp[!rownames(gset_log2exp) %in% names(gset_trsf_with_NA),]
# gset_log2exp_pass <- gset_log2exp
# rownames(gset_log2exp) <- seq_len(length.out = nrow(gset_log2exp))
# gset_log2exp_rows <- apply(X = gset_log2exp,
#                            MARGIN = 1,
#                            function(x) {
#                              length(x[is.na(x)]) == 0
#                              })
# gset_log2exp_pass <- gset_log2exp_rows[gset_log2exp_rows]
# gset_log2exp_try <- gset_log2exp[rownames(gset_log2exp) %in% names(gset_log2exp_pass),]

sig_set <- unlist(lapply(sig_up_genes,
                         function(x) {
                           rownames(x)
                           }))

gset_log2exp_sig <- gset_log2exp_pass[rownames(gset_log2exp_pass) %in% sig_set,]
gset_log2exp_sig_ifnsignature <- gset_log2exp_pass[rownames(gset_log2exp_pass) %in% test_ifn_signature_probeInd_genes$rname,]
gset_log2exp_sig_ifnsignature_genename <- sapply(rownames(gset_log2exp_sig_ifnsignature),function(x) {test_ifn_signature_probeInd_genes[test_ifn_signature_probeInd_genes$rname %in% x,"gene"]})

colannot <- data.frame(cell_type = gset_meta$cell_type)
rownames(colannot) <- rownames(gset_meta)

pheatmap(mat = gset_log2exp_sig_ifnsignature, 
         show_colnames = FALSE,
         labels_row = gset_log2exp_sig_ifnsignature_genename,
         annotation_col = colannot,fontsize = 7.5,
         main="Interferon signature genes (log2(fluorescence)")

pheatmap(mat = gset_log2exp_sig, 
         show_colnames = FALSE,
         show_rownames = FALSE,
         annotation_col = colannot,fontsize = 7.5,
         main="All significantly-expressed genes (log2(fluorescence)")

```

Perhaps we can re-run GSEA on all of the "significant" genes?


# Scraps

Decide tests
```{}
# decideTests will determine which genes are significantly expressed (up or down) for each contrast that we tested. 
fit_bycell_bytime_decideTests <- decideTests(object = fit_bycell_bytime_ebayes,method = "global",adjust.method = "fdr",p.value = alpha)
# this gives us the top table, and we can select specific genes based on the output from decideTests
tT_bycell_bytime <- topTable(fit_bycell_bytime_ebayes, adjust="fdr", sort.by="B",number = nrow(fit_bytime_ebayes))
# summarize which genes are significant
print(summary(fit_bycell_bytime_decideTests))
# get the genes that 
```

```{}
# compare breast to all 
cont.matrix <- makeContrasts(breast-colon, levels=design)
# fit1 <- contrasts.fit(fit,cont.matrix)
fit2 <- contrasts.fit(fit_bycell, cont.matrix)
# fit1 <- eBayes(fit1, 1)
fit2 <- eBayes(fit2, 0.01)
tT <- topTable(fit2, adjust="fdr", sort.by="B", number=250)
# allT <- topTable(fit2, adjust="none", sort.by="B",number = nrow(fit2))
tT <- topTable(fit2, adjust="fdr", sort.by="B",number = nrow(fit2))

# write results
# write.table(x = tT,file = paste(getwd(),"topTable.txt",sep = "/"),quote = FALSE,sep = "\t",row.names = TRUE,col.names = TRUE)

# allT_subset <- subset(allT, select=c("ID","adj.P.Val","P.Value","t","B","logFC","GENE_SYMBOL","GENE_NAME"))
tT_subset <- subset(tT, select=c("ID","adj.P.Val","P.Value","t","B","logFC","GENE_SYMBOL","GENE_NAME"))

```

Depict the design
```{}
library(pheatmap)
pheatmap(design,show_rownames = FALSE)
```


Do I also have to do the demethylation analysis?


